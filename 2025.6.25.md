>Written with [StackEdit](https://stackedit.io/).
# R study^2025.6.25^
## 常量与变量~study~
常量是指直接写在程序中的值，包括数值、字符串:
1. 数值包括整型、单精度、双精度等，一般不需要区分
2. 字符型常量用两个双撇号或两个单撇号包围，如"Li Ming" 或'Li Ming'
3. 逻辑型常量只有 TRUE 和 FALSE，表示真值和假值
4. 缺失值用 NA 表示

变量，用来保存输入的值或者计算得到的值。在 R 中，变量可以保存所有的数据类型，比如标量、向量、矩阵、数据框、函数等：
- 变量名，R 变量名必须以字母、数字、下划线和句点组成，变量名的第一个字符不能取为数字
- 变量名是区分大小写的，y 和 Y 是两个不同的变量名
- 用 <-赋值的方法定义变量。<-也可以写成 =，但是 <-更直观
- 举例`x5 <- 6.25`

R数据类型：
- R 语言基本的数据类型有数值，逻辑型（TRUE, FALSE），文本（字符串）
- R 语言数据结构包括**向量，矩阵和数据框，多维数组，列表，对象**等。数据中元素、行、列还可以用名字访问。最基本的是**向量类型**
---

## 数值型向量及其运算
> 向量是将若干个基础类型相同的值存储在一起，各个元素可以按序号访问。如果将若干个数值存储在一起可以用序号访问，就叫做一个数值型向量

用 c() 函数把多个元素或向量组合成一个向量:
```r
marks <- c(10,6,4,7,8)
x <- c(1:3,10:13)
x1 <- c(1,2)
x2 <- c(3,4)
x <- c(x1,x2)
x
length(x)
```
length(x) 可以求 x 的长度。长度为零的向量表示为 numeric(0)。numeric() 函数可以用来初始化一个指定元素个数而元素都等于零的数值型向量，如 numeric(10) 会生成元素为 10 个零的向量。

> 单个数值称为标量，R 没有单独的标量类型，标量实际是长度为 1 的向量

标量和标量运算:
- R 中四则运算用 + - * / ^ 表示 (加、减、乘、除、乘方)
- R 中四则运算仍遵从通常的优先级规则，可以用圆括号 () 改变运算的先后次序
- 除了加、减、乘、除、乘方，R 还支持整除运算和求余运算。用%/% 表示整除，用%% 表示求余
```r
1.5 + 2.3 - 0.6 + 2.1*1.2 - 1.5/0.5 + 2^3
1.5 + 2.3 - (0.6 + 2.1)*1.2 - 1.5/0.5 + 2^3
5 %/% 3
## [1] 1
5 %% 3
## [1] 2
```
- 向量与标量的运算为每个元素与标量的运算
- 四则运算时如果有缺失值，缺失元素参加的运算相应结果元素仍缺失
- 等长向量的运算为对应元素两两运算
- 两个不等长向量的四则运算，如果其长度为倍数关系，规则是每次从头重复利用短的一个
- 如果两个向量的长度不是倍数关系，会给出警告信息
```r
x <- c(1, 10)
x + 2
## [1] 3 12

c(1, NA, 3) + 10
## [1] 11 NA 13

x1 <- c(1, 10)
x2 <- c(4, 2)
x1 + x2
## [1] 5 12

x1 <- c(10, 20)
x2 <- c(1, 3, 5, 7)
x1 + x2
## [1] 11 23 15 27
```
• 舍入：ceiling, floor, round, signif, trunc, zapsmall
• 符号函数 sign
• 绝对值 abs
• 平方根 sqrt
• 对数与指数函数 log, exp, log10, log2
• 三角函数 sin, cos, tan
• 反三角函数 asin, acos, atan, atan2
• 双曲函数 sinh, cosh, tanh
• 反双曲函数 asinh, acosh, atanh

排序函数：
 - sort(x) 返回排序结果。rev(x) 返回把各元素排列次序反转后的结果。order(x) 返回排序用的下标。
```r
x <- c(33, 55, 11)
sort(x)
## [1] 11 33 55
rev(sort(x))
## [1] 55 33 11
order(x)
## [1] 3 1 2
x[order(x)]
## [1] 11 33 55
```
统计函数：
 - sum(求和), mean(求平均值), var(求样本方差), sd(求样本标准差), min(求最小值), max(求最大值), range(求最小值和最大值) 等函数称为统计函数，把输入向量看作样本，计算样本统计量
 - rod 求所有元素的乘积。cumsum 和 cumprod 计算累加和累乘积
 - 其它一些类似函数有 pmax, pmin, cummax, cummin
```r
cumsum(1:5)
## [1] 1 3 6 10 15
cumprod(1:5)
## [1] 1 2 6 24 120
```
生成规则序列的函数
 - seq 函数是冒号运算符的推广。比如，seq(5) 等同于 1:5。seq(2,5) 等同于 2:5。seq(11, 15, by=2) 产生11,13,15。seq(0, 2*pi, length.out=100) 产生从 0 到 2𝜋 的等间隔序列，序列长度指定为 100
 - rep() 函数用来产生重复数值。为了产生一个初值为零的长度为 n 的向量，用 x <- rep(0, n)。rep(c(1,3),2) 把第一个自变量重复两次，结果相当于 c(1,3,1,3)
 - rep(c(1,3), c(2,4)) 则需要利用 R 的**一般向量化规则**，<u>把第一自变量的第一个元素 1 按照第二自变量中第一个元素 2 的次数重复，把第一自变量中第二个元素 3 按照第二自变量中第二个元素 4 的次数重复</u>，结果相当于c(1,1,3,3,3,3)
 - 如果希望重复完一个元素后再重复另一元素，用 each= 选项，比如 rep(c(1,3), each=2) 结果相当于c(1,1,3,3)
```r
seq(2,10,by=2)
[1]  2  4  6  8 10
seq(0,2*pi,length.out=5)
[1] 0.000000 1.570796 3.141593 4.712389 6.283185
 x <- rep(c(1,3),2)
 x
[1] 1 3 1 3
rep(c(2,3,4),each=3)
[1] 2 2 2 3 3 3 4 4 4
```
---
## 逻辑型向量及其运算
逻辑型向量与比较运算：
>逻辑型是 R 的基本数据类型之一，只有两个值 TRUE 和 FALSE, 缺失时为 NA
 - 向量比较结果为逻辑型向量
 - 向量比较也遵从 R 的**向量间运算的一般规则**：向量与标量的运算是向量每个元素与标量都分别运算一次，等长向量的运算时对应元素的运算，不等长但长度为倍数关系的向量运算是把短的从头重复利用
 - 与 NA 比较产生 NA
 - 为了**判断向量每个元素是否 NA**，用`is.na( )` 函数
 - 用 `is.finite( )` 判断向量每个元素是否 Inf 值

```r
sele <- (log10(15) < 2); print(sele)
## [1] TRUE
c(1, 3, 5) > 2
## [1] FALSE TRUE TRUE
(1:4) >= (4:1)
## [1] FALSE FALSE TRUE TRUE
c(1, NA, 3) > 2
## [1] FALSE NA TRUE
is.na(c(1, NA, 3) > 2)
## [1] FALSE TRUE FALSE
is.finite(c(1, NA, 3) > 2)
[1]  TRUE FALSE  TRUE
```
|符号|意义|用法|
|--|--|--|
|<|小于||
|<=|小于等于|
|>|大于
|>=|大于等于
|==|等于
|!=|不等于
|%in%|属于

- %in% 是比较特殊的比较，`x %in% y` 的运算把向量 y 看成集合，运算结果是一个逻辑型向量，第 𝑖 个元素的值为x 的第 𝑖 元素是否属于 y 的逻辑型值
- 函数 `match(x, y)` 起到和 `x %in% y` 运算类似的作用，但是其返回结果不是找到与否，而是对 x 的每个元素，找

到其在 y 中首次出现的下标，找不到时取缺失值
```r
c(1,3) %in% c(2,3,4)
## [1] FALSE TRUE
c(NA,3) %in% c(2,3,4)
## [1] FALSE TRUE
c(1,3) %in% c(NA, 3, 4)
## [1] FALSE TRUE
c(NA,3) %in% c(NA, 3, 4)
## [1] TRUE TRUE
```
```r
match(c(1, 3), c(2,3,4,3))
## [1] NA 2
```
逻辑运算

> 为了表达如 “𝑥 > 0 而且 𝑥 < 1”, “𝑥 ≤ 0 或者 𝑥 ≥ 1” 之类的复合比较，需要使用逻辑运算把两个比较连接起来
 - 逻辑运算符为 &, | 和!, 分别表示 “同时成立”、“两者至少其一成立”、“条件的反面”
 - `!(age<=3 | sex=='女')` 表示既非婴儿也非妇女。为了确定运算的先后次序可以用圆括号 ( ) 指定
 - && 和 || 分别为短路的标量逻辑与和短路的标量逻辑或，仅对两个标量进行运算，如果有向量也仅使用第一个元素
 - 一般用在 if 语句、while 语句中，且只要第一个比较已经决定最终结果就不计算第二个比较
 - 若 cond 是逻辑向量，用 `all(cond)` 测试 cond 的所有元素为真；用 any(cond) 测试 cond 至少一个元素为真。cond 中允许有缺失值，结果可能为缺失值。
```r
c(1, NA, 3) > 2
## [1] FALSE NA TRUE
all(c(1, NA, 3) > 2)
## [1] FALSE
any(c(1, NA, 3) > 2)
## [1] TRUE
all(NA)
## [1] NA
any(NA)
## [1] NA
```
 - 函数 which() 返回真值对应的所有下标
```r
which(c(FALSE, TRUE, TRUE, FALSE, NA))
## [1] 2 3
which((11:15) > 12)
## [1] 3 4 5
```
 - 函数 identical(x,y) 比较两个 R 对象 x 与 y 的内容是否完全相同，结果只会取标量 TRUE 与 FALSE 两种。
```r
identical(c(1,2,3), c(1,2,NA))
## [1] FALSE
identical(c(1L,2L,3L), c(1,2,3))
## [1] FALSE
```
> 其中第二个结果假值是因为前一向量是整数型，后一向量是实数型
 - 函数 all.equal() 与 identical() 类似，但是在比较数值型时不区分整数型与实数型，而且相同时返回标量TRUE，但是不同时会返回一个说明有何不同的字符串。
```r
all.equal(c(1,2,3), c(1,2,NA))
## [1] "'is.NA' value mismatch: 1 in current 0 in target"
all.equal(c(1L,2L,3L), c(1,2,3))
## [1] TRUE
```
 - 函数 duplicated() 返回每个元素是否为重复值的结果
 - 用函数 unique() 可以返回去掉重复值的结果
```r
duplicated(c(1,2,1,3,NA,4,NA))
## [1] FALSE FALSE TRUE FALSE FALSE FALSE TRUE
```
---
## 字符型数据及其处理
### 字符型向量，转义字符和原始字符串
 - 字符型向量是元素为字符串的向量。字符串在程序中写成用两个双撇号包围或者用两个单撇号包围的内容
 - 空字符串并不能自动认为是缺失值，字符型的缺失值仍用 NA 表示
 - 为了在字符串中**表示一个双撇号**，可以用反斜杠在前面标明，称为 **“转义”**，其中`"\n"` 也是转义的字符，表示**换行**
 - 当需要转义的内容较多时，可以使用原始字符串 (raw string)，方法是用 `r"(...)"` 的格式
```r
s1 <- c('abc', ' ','a cat', NA, '李明')
cat("\"\n")
## "
cat(r"(C:\disk\course\math\nFinished!\n)")
## C:\disk\course\math\nFinished!\n
```
> 原始字符串如果内容中包含了圆括号，可以将边界的圆括号改为方括号 `[]` 或者大括号 `{}`。如果这样也不能避免歧义，可以在开始和结尾加上相同个数的减号，格式为 `r"--(...)--"`

### paste 函数
paste()是用来连接两个字符型向量的函数，默认空格连接，**一一对应**`paste(c('ab','cd'),c('ef','gh'))`的输出结果是`[1] "ab ef" "cd gh"`
- paste() 在连接两个字符型向量时采用 R 的一般向量间运算规则，而且可以自动把数值型向量转换为字符型向量
- 用 sep= 指定分隔符，如 `paste("x", 1:3, sep="")` 结果相当于 `c("x1", "x2", "x3")`
- 使用 collapse= 参数可以把字符型向量的各个元素连接成一个单一的字符串, 如 `paste(c("a", "b", "c"),collapse="")` 结果相当于`"abc"`
- `toupper()` 函数把字符型向量内容转为大写，`tolower()` 函数转为小写
- 比如，`toupper('aB cd')` 结果为`"ABCD"`，`tolower(c('aB', 'cd'))` 结果相当于 `c("ab" "cd")`。**这两个函数可以用于不区分大小写的比较**，比如，不论 `x` 的值是`'JAN'`, `'Jan'`还是`'jan'`，`toupper(x)=='JAN'`的结果都为 `TRUE`

### 字符串长度
用 `nchar(x, type='bytes')` 计算字符型向量 `x` 中每个字符串的以字节为单位的长度。中英文不一样，中文通常一个汉字占两个字节，英文字母、数字、标点占一个字节
	用 `nchar(x, type='chars')` 计算字符型向量 `x` 中每个字符串的以字符个数为单位的长度，这时一个汉字算一个单位
	在画图时可以用 `strwidth()` 函数计算某个字符串或表达式占用的空间大小

### 取子串

`substr(x, start, stop)`从字符串 x 中取出从第 start 个到第 stop 个的子串
用 `substring(x, start)` 可以从字符串 x 中取出从第 start 个到末尾的子串
```r
substr('JAN07', 1, 3)
## [1] "JAN"
substr(c('JAN07', 'MAR66'), 1, 3)
## [1] "JAN" "MAR"
substring(c('JAN07', 'MAR66'), 4)
## [1] "07" "66"
```

### 类型转换

> 用 `as.numeric()` 把内容是数字的字符型值转换为数值
`as.numeric()` 是向量化的，可以转换一个向量的每个元素为数值型
```r
substr('JAN07', 4, 5)
## [1] "07"
substr('JAN07', 4, 5) + 2000
## Error in substr("JAN07", 4, 5) + 2000 :
## non-numeric argument to binary operator
as.numeric(substr('JAN07', 4, 5)) + 2000
## [1] 2007
as.numeric(substr(c('JAN07', 'MAR66'), 4, 5))
## [1] 7 66
```
用 `as.character()` 函数把数值型转换为字符型,如果自变量本来已经是字符型则结果不变
```r
as.character((1:5)*5)
## [1] "5" "10" "15" "20" "25"
```
为了用指定的格式数值型转换成字符型，可以使用 `sprintf()` 函数，其**用法**与 C 语言的 `sprintf()` 函数相似，只不过是**向量化**的
```r
sprintf('file%03d.txt', c(1, 99, 100))
## [1] "file001.txt" "file099.txt" "file100.txt"
sprintf('file%01d.txt', c(1, 99, 100,8888))
[1] "file1.txt"    "file99.txt"   "file100.txt" 
[4] "file8888.txt"
```
readr 包的 `parse_number()` 输入一个字符串向量，对每个字符串，找到**第一个能识别为数值的内容**，**舍弃其它内容**，返回转换浮点型结果。**没有数值时返回缺失值**，并增加一个表格用来记录所有的不成功转换

> readr中还有许多其他的函数，如`parse_integer,parse_double,parse_logical,parse_character`等函数，这些函数不允许要读取内容以外的内容存在，比如 `readr::parse_number("text-123")` 能正确读取`-123`，而`readr::parse_integer("text-123")` 则会返回**缺失值**

## 字符替代功能
用 `gsub()` 可以替换字符串中的子串，这样的功能经常用在数据清理中。比如，把数据中的中文标点改为英文标点，去掉空格，等等
```r
x <- '1, 3; 5'
gsub(';', ',', x, fixed=TRUE)
## [1] "1, 3, 5"
```
## 正则表达式
> 正则表达式 ***(regular expression)*** 是一种匹配某种字符串模式的方法。用这样的方法，可以从字符串中查找某种模式的出现位置，替换某种模式，等等。这样的技术可以用于文本数据的预处理，比如用网络爬虫下载的大量网页文本数据。
R 中支持 perl 语言格式的正则表达式，grep() 和 grepl() 函数从字符串中查询某个模式，sub() 和

gsub() 替换某模式。比如，下面的程序把多于一个空格替换成一个空格



<!--stackedit_data:
eyJoaXN0b3J5IjpbLTg1MzYzNTkxMCwtNDMxNzk3NTg0LC0yOD
MwODQxNzAsNDE4MTUwMzY4XX0=
-->