# R study^2025.7.15^
## R 向量下标和子集~study~
### 正/负整数下标
负下标表示**扣除相应的元素后**的子集
```r
x <- c(1,4,6.25)
x[-2]
## [1] 1.00 6.25
x[-c(1,3)]
## [1] 4
```

> 负整数下标不能与正整数下标同时用来从某一向量中取子集，比如，x[c(1,-2)] 没有意义


x[] 表示取 x 的全部元素作为子集。这与 x 本身不同
```r
x <- c(1,4,6.25)
x[] <- 999
x
## [1] 999 999 999
x <- c(1,4,6.25)
x <- 999
x
## [1] 999
```
### 下标超界
设向量 x 长度为 𝑛, 则使用正整数下标时下标应在 `{1, 2, … , 𝑛}` 中取值。如果使用大于 𝑛 的下标，读取时返回缺失值，并不出错。**给超出 𝑛 的下标元素赋值**，则向量**自动变长，中间没有赋值的元素为缺失值**
```r
x <- c(1,4,6.25)
x[5]
## [1] NA
x
## [1] 1.00 4.00 6.25
x[5] <- 9
x
## [1] 1.00 4.00 6.25 NA 9.00
```

> 虽然 R 的语法对下标超界不视作错误，但是这样的做法往往来自不良的程序思路，而且对程序效率有影响，所以实际编程中应避免下标超界

### 逻辑下标
下标可以是与向量等长的逻辑表达式，一般是关于本向量或者与本向量等长的其它向量的比较结果
```r
x <- c(1,4,6.25)
x[x > 3]
## [1] 4.00 6.25
```
取出 x 的大于 3 的元素组成的子集
逻辑下标除了用来对向量取子集，还经常用来对数据框取取子集，也用在向量化的运算中
```r
f <- function(x){
y <- numeric(length(x))
y[x >= 0] <- 1
y[x < 0] <- 0 # 此语句多余
y
}
```
`ifelse()` 函数:对上面的示性函数，如果 x 是一个向量，输出 y 向量可以写成 `y <- ifelse(x>=0, 1, 0)`
```r
x <- c(-1,2)
y <- ifelse(x>=0, 1, 0)
```
要注意的是，如果逻辑下标中有缺失值，对应结果也是缺失值。所以，在用逻辑下标作子集选择时，一定要考虑到缺失值问题。正确的做法是加上`!is.na` 前提
```r
x <- c(1, 4, 6.25, NA)
x[x > 2]
## [1] 4.00 6.25 NA
x[!is.na(x) & x > 2]
## [1] 4.00 6.25
```
---

### `which()、which.min()、which.max()` 函数

函数 which() 可以用来找到满足条件的**下标**
```r
x <- c(3, 4, 3, 5, 7, 5, 9)
which(x > 5)
## [1] 5 7
seq(along=x)[x > 5]
## [1] 5 7
```

这里 seq(along=x) 会生成由 x 的下标组成的向量。用 which.min()、which.max 求最小值的下标和最大值的下标，不唯一时只取第一个
*(似乎很多函数，类似情况都只会取第一个）*

### 元素名
向量可以为每个元素命名
三种方法/格式

 1. `ages <- c("李明"=30, "张聪"=25, "刘颖"=28)`
 2. `ages <- c(30, 25, 28)  names(ages) <- c(" 李明", "张聪", "刘颖")`
 3. `ages <- setNames(c(30, 25, 28), c("李明", "张聪", "刘颖"))`

这时可以用元素名或元素名向量作为向量的下标
```r
ages[" 张聪"]
## 张聪
## 25
ages[c(" 李明", " 刘颖")]
## 李明 刘颖
## 30 28
ages[" 张聪"] <- 26
```
注意：空格也算元素，会影响代码运行，要注意观察
是向量作为下标！！`x[c()]`

带有元素名的向量也可以是字符型或其它基本类型

> 用 unname(x) 返回去掉了元素名的 x 的副本，用 names(x) <- NULL 可以去掉 x 的元素名
```r
sex <- c("李明"="男", "张聪"="男", "刘颖"="女")
unname(sex)
[1] "男" "男" "女"
sex
李明 张聪 刘颖 
"男" "男" "女"
names(sex) <- NULL
sex
[1] "男" "男" "女"
```
---
### 用 R 向量下标作映射
R 在使用整数作为向量下标时，允许使用重复下标，这样可以把数组 x 看成一个 1 ∶ 𝑛 的整数到 x[1], x[2], …,x[n] 的一个映射表, 其中 𝑛 是 x 的长度

```r
items <- c(3,2,1,1,2,2,3)
y <- price_map[items]; print(y)
## [1] 168 88 68 68 88 88 168
```
R 向量可以用字符型向量作下标，**字符型下标**也**允许重复**，所以可以把带有元素名的 R 向量看成是元素名到元素值的映射表
```r
sex <- c(" 男", " 男", " 女", " 女", " 男", " 女", " 女", " 女", " 女", " 男")
sex_color <- c(" 男"="blue", " 女"="red")
cols <- sex_color[sex]; print(cols)
##  男 男 女 女 男 女 女 女 女 男
## "blue" "blue" "red" "red" "blue" "red" "red" "red" "red" "blue"
unname(cols)
## [1] "blue" "blue" "red" "red" "blue" "red" "red" "red" "red" "blue"
```
这样的映射结果中带有不必要的元素名，用 `unname()` 函数可以去掉元素名

### 集合运算

 - 可以把向量 x 看成一个集合，但是其中的元素允许有重复。用 `unique(x)` 可以获得 `x` 的所有不同值
 - 用 a %in% x 判断 a 的每个元素是否属于向量 x
 - 函数 `match(x, table)` 对向量 x 的每个元素，从向量 `table` 中查找其首次出现位置并返回这些位置。没有匹配到的元素位置返回 NA_integer_(整数型缺失值)
 - 用 `intersect(x,y)` 求交集，结果中不含重复元素
 - 用 `union(x,y)` 求并集，结果中不含重复元素
 - 用 `setdiff(x,y)` 求差集，即 x 的元素中不属于 y 的元素组成的集合，结果中不含重复元素
 - 用 `setequal(x,y)` 判断两个集合是否相等，不受次序与重复元素的影响
主要注意函数：***intersect(x,y)、union(x,y)、setdiff(x,y)、setequal(x,y)***
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE4NDc4NjQ2OTNdfQ==
-->